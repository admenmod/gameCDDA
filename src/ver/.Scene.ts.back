// //@ts-ignore
// type get_class<T extends Scene> = T['_class'];

	// export type PickArgs<T extends new (...args: any) => any> = T extends new (...args: infer P) => any ? P : never;
	// export type TREE = Record<string, readonly [typeof Scene, ...any]>;
	// export type Tree<T extends Scene.TREE> = { [K in keyof T]: getInstanceOf<T[K][0]>; };


	//! export type PickArgs<T extends new (...args: any) => any> = T extends new (...args: infer P) => any ? P : never;

	//! export type TREE<T extends Record<string, Scene> = Record<string, Scene>> =
	//! 	{ [K in keyof T]: get_class<T[K]>; }

	//! export type Tree<T extends Scene.TREE> = { [K in keyof T]: getInstanceOf<T[K]>; };


	// export type TREE<T extends Record<string, typeof Scene> = Record<string, typeof Scene>> =
	// 	{ readonly [K in keyof T]: readonly [T[K], ...Scene.PickArgs<T[K]>]; }
	// export type TREE<T extends Record<string, Scene> = Record<string, Scene>> =
	// 	{ [K in keyof T]: [convertA<T[K]>, ...Scene.PickArgs<convertA<T[K]>>]; }
	//
	// export type Tree<T extends Scene.TREE> = { [K in keyof T]: getInstanceOf<T[K][0]>; };




		// = Record<keyof T, readonly [T[keyof T], ...Scene.PickArgs<T[keyof T]>]>;
	// export type TREE<T extends Record<string, Scene> = Record<string, Scene>>
	// 	= Record<string, readonly [T[keyof T], ...any]>;

	// export type Tree<T extends typeof Scene, _T extends T['TREE']> = { [K in keyof _T]: _T[K]; };
	// export type Tree<T extends typeof Scene, _T extends T['TREE']> = { [K in keyof _T]: getInstanceOf<_T[0]>; };
	// export type Tree<T extends typeof Scene, _T extends T['TREE']> = { readonly [K in keyof _T]: getInstanceOf<_T[K][0]>; };
